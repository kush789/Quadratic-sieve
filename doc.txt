mp_limb_t get_smoothness_bound(mp_limb_t n)

	This function returns the smoothness B which is to be used in the
	sieve. The numbers will be checked for B smoothness based on this
	value.

	It is calculated as follows:

	B = e ^ ((0.5)*((ln(n))*(ln(ln(n))))^0.5)

mp_limb_t* get_primes(mp_limb_t B, mp_limb_t* num)

	This function returns a pointer to an array of prime numbers lesser
	than or equal to the upper_bound supplied. It uses a cached prime
	table as we know that the upper bound cannot exceed 650, i.e. the 
	maximum smoothness value for a 64 bit integer.

	- B is smoothness_bound calculated by get_smoothness_bound().
	- num gets set to the number of primes in the returned array.

mp_limb_t* get_factor_arr(mp_limb_t n, mp_limb_t prime_arr[], mp_limb_t num, mp_limb_t* fac_count)

	This function returns a pointer to an array of prime numbers whcih
	forms the factor base for further sieving. 

	- n is the number being factored,
	- prime_arr[] is an array of primes which is B smooth where B has been 
	  calculated as per get_smoothness_bound. 
	- num is the number of elements in prime_arr[].
	- fac_count gets set to the number of elements in the returned factor base.

mp_limb_t* get_factor_base(mp_limb_t n, mp_limb_t* factor_base_count)

	Returns the factor base for quadratic sieving of a number n. Makes 
	calls to get_smoothness_bound(), get_primes(), get_factor_arr(). 

	factor_base_count gets set to the number of elements in the returned
	factor_base;